// lex.yy.cpp generated by reflex 1.0.9 from hw0.l

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  OPTIONS USED                                                              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define REFLEX_OPTION_bison               true
#define REFLEX_OPTION_flex                true
#define REFLEX_OPTION_lex                 yylex
#define REFLEX_OPTION_lexer               yyFlexLexer
#define REFLEX_OPTION_noyywrap            true
#define REFLEX_OPTION_outfile             lex.yy.cpp
#define REFLEX_OPTION_prefix              yy

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %top{ user code %}                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 1 "hw0.l"

	#include <cstdio>
	#include <iostream>
	#include <iomanip>
	#include <string>
	using namespace std;


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  FLEX-COMPATIBLE DEFINITIONS                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define INITIAL (0)
#define quote (1)
#define squote (2)
#define YY_NUM_RULES (8)

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  REGEX MATCHER                                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  FLEX-COMPATIBLE ABSTRACT LEXER CLASS                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/flexlexer.h>
#undef yytext
#undef yyleng
#undef yylineno
typedef reflex::FlexLexer<reflex::Matcher> FlexLexer;

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  LEXER CLASS                                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

class yyFlexLexer : public FlexLexer {
#line 9 "hw0.l"

	std::string string1;
	public:
		void results() {
			cout << string1 << endl;
		}

 public:
  yyFlexLexer(
      const reflex::Input& input = reflex::Input(),
      std::ostream        *os    = NULL)
    :
      FlexLexer(input, os)
  {
  }
  virtual int yylex();
  int yylex(
      const reflex::Input& input,
      std::ostream        *os = NULL)
  {
    in(input);
    if (os)
      out(*os);
    return yylex();
  }
};

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  BISON                                                                     //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

yyFlexLexer YY_SCANNER;

#ifndef YY_EXTERN_C
#define YY_EXTERN_C
#endif

char *yytext;
yy_size_t yyleng;
int yylineno;
YY_EXTERN_C int yylex(void)
{
  int res = YY_SCANNER.yylex();
  yytext = const_cast<char*>(YY_SCANNER.YYText());
  yyleng = static_cast<yy_size_t>(YY_SCANNER.YYLeng());
  yylineno = static_cast<int>(YY_SCANNER.lineno());
  return res;
}

#define yytext const_cast<char*>(YY_SCANNER.YYText())
#define yyleng static_cast<yy_size_t>(YY_SCANNER.YYLeng())
#define yylineno static_cast<int>(YY_SCANNER.lineno())

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 2: rules                                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

int yyFlexLexer::yylex()
{
  static const reflex::Pattern PATTERN_INITIAL("(?m)([\"])|(['])");
  static const reflex::Pattern PATTERN_quote("(?m)([a-z])|([\\x20])|([\"])");
  static const reflex::Pattern PATTERN_squote("(?m)([a-z])|([\\x20])|(['])");
  if (!has_matcher())
  {
    matcher(new Matcher(PATTERN_INITIAL, stdinit(), this));
    YY_USER_INIT
  }
  while (true)
  {
    switch (start())
    {
      case INITIAL:
        matcher().pattern(PATTERN_INITIAL);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              return 0;
            }
            else
            {
              output(matcher().input());
            }
            YY_BREAK
          case 1: // rule at line 24: ["]
            YY_USER_ACTION
#line 24 "hw0.l"
{start(quote); string1.append("&ldquo ");}
            YY_BREAK
          case 2: // rule at line 29: [']
            YY_USER_ACTION
#line 29 "hw0.l"
{ start(squote); string1.append("&lquo ");}
            YY_BREAK
        }
        break;
      case quote:
        matcher().pattern(PATTERN_quote);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              return 0;
            }
            else
            {
              output(matcher().input());
            }
            YY_BREAK
          case 1: // rule at line 25: [a-z]
            YY_USER_ACTION
#line 25 "hw0.l"
{string1.append(text());}
            YY_BREAK
          case 2: // rule at line 26: [\x20]
            YY_USER_ACTION
#line 26 "hw0.l"
{string1.append(text());}
            YY_BREAK
          case 3: // rule at line 27: ["]
            YY_USER_ACTION
#line 27 "hw0.l"
{start(INITIAL); string1.append(" &rdquo");}

            YY_BREAK
        }
        break;
      case squote:
        matcher().pattern(PATTERN_squote);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              return 0;
            }
            else
            {
              output(matcher().input());
            }
            YY_BREAK
          case 1: // rule at line 30: [a-z]
            YY_USER_ACTION
#line 30 "hw0.l"
{string1.append(text());}
            YY_BREAK
          case 2: // rule at line 31: [\x20]
            YY_USER_ACTION
#line 31 "hw0.l"
{string1.append(text());}
            YY_BREAK
          case 3: // rule at line 32: [']
            YY_USER_ACTION
#line 32 "hw0.l"
{start(INITIAL); string1.append(" &rdquo");}

            YY_BREAK
        }
        break;
      default:
        return 0;
    }
  }
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 3: user code                                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 35 "hw0.l"

int main(int argc, char **argv) {
	FILE *fd = stdin;
	if(argc > 1 && (fd = fopen(argv[1], "r")) == NULL) {
		exit(EXIT_FAILURE);
	}

	yyFlexLexer lexer(fd);

	lexer.yylex();

	lexer.results();

	if(fd != stdin) {
		fclose(fd);
	}
	return 0;
}

